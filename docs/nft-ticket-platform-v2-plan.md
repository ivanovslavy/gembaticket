# NFT Ticket Platform v2 â€” ĞŸÑŠĞ»ĞµĞ½ Ğ¿Ğ»Ğ°Ğ½ Ğ·Ğ° Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°

**ĞŸÑ€Ğ¾ĞµĞºÑ‚:** Non-custodial Ğ±Ğ¸Ğ»ĞµÑ‚Ğ½Ğ° Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ° Ñ NFT Ğ±Ğ¾Ğ½ÑƒÑ
**ĞšĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ñ:** GEMBA EOOD
**Ğ”Ğ°Ñ‚Ğ°:** 08.02.2026
**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:** Ğ—Ğ° Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¸Ğµ

---

## 1. Ğ’Ğ˜Ğ—Ğ˜Ğ¯ Ğ˜ ĞŸĞ Ğ˜ĞĞ¦Ğ˜ĞŸĞ˜

### 1.1 ĞÑĞ½Ğ¾Ğ²Ğ½Ğ° Ğ²Ğ¸Ğ·Ğ¸Ñ

Ğ‘Ğ¸Ğ»ĞµÑ‚Ğ½Ğ° Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ°, ĞºĞ¾ÑÑ‚Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¸ ĞºĞ°Ñ‚Ğ¾ Eventbrite Ğ·Ğ° ĞºÑ€Ğ°Ğ¹Ğ½Ğ¸Ñ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ», Ğ½Ğ¾ Ğ¿Ğ¾Ğ´ ĞºĞ°Ğ¿Ğ°ĞºĞ° Ğ¸Ğ·Ğ¿Ğ¾Ğ»Ğ·Ğ²Ğ° blockchain Ğ¸ NFT Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ·Ğ° ÑĞ¸Ğ³ÑƒÑ€Ğ½Ğ¾ÑÑ‚, Ğ°Ğ²Ñ‚ĞµĞ½Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ÑÑ‚ Ğ¸ ĞºĞ¾Ğ»ĞµĞºÑ†Ğ¸Ğ¾Ğ½ĞµÑ€ÑĞºĞ° ÑÑ‚Ğ¾Ğ¹Ğ½Ğ¾ÑÑ‚. ĞŸĞ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»Ğ¸Ñ‚Ğµ ĞĞ• Ñ‚Ñ€ÑĞ±Ğ²Ğ° Ğ´Ğ° Ğ·Ğ½Ğ°ÑÑ‚ Ğ½Ğ¸Ñ‰Ğ¾ Ğ·Ğ° blockchain.

### 1.2 ĞšĞ»ÑÑ‡Ğ¾Ğ²Ğ¸ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ğ¸

- **ZERO CUSTODY** â€” Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ° Ğ½Ğµ Ğ´ÑŠÑ€Ğ¶Ğ¸ Ğ½Ğ¸Ñ‚Ğ¾ crypto, Ğ½Ğ¸Ñ‚Ğ¾ fiat, Ğ½Ğ¸Ñ‚Ğ¾ private keys, Ğ½Ğ¸Ñ‚Ğ¾ NFT-Ñ‚Ğ° Ğ¾Ñ‚ Ğ¸Ğ¼ĞµÑ‚Ğ¾ Ğ½Ğ° Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»Ğ¸
- **BLOCKCHAIN INVISIBLE** â€” Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»Ğ¸Ñ‚Ğµ (Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ¸ Ğ¸ ĞºÑƒĞ¿ÑƒĞ²Ğ°Ñ‡Ğ¸) Ñ€Ğ°Ğ±Ğ¾Ñ‚ÑÑ‚ Ñ email, ĞºĞ°Ñ€Ñ‚Ğ¸ Ğ¸ QR ĞºĞ¾Ğ´Ğ¾Ğ²Ğµ; blockchain Ğµ Ğ½ĞµĞ²Ğ¸Ğ´Ğ¸Ğ¼ ÑĞ»Ğ¾Ğ¹ Ğ¾Ñ‚Ğ´Ğ¾Ğ»Ñƒ
- **GEMBAPAY POWERED** â€” Ğ²ÑĞ¸Ñ‡ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‰Ğ°Ğ½Ğ¸Ñ (fiat Ğ¸ crypto) Ğ¼Ğ¸Ğ½Ğ°Ğ²Ğ°Ñ‚ Ğ¿Ñ€ĞµĞ· GembaPay; GEMBA EOOD Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ğ²Ğ° ÑĞ°Ğ¼Ğ¾ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼ĞµĞ½Ğ° Ñ‚Ğ°ĞºÑĞ°
- **NFT = Ğ‘ĞĞĞ£Ğ¡** â€” Ğ±Ğ¸Ğ»ĞµÑ‚ÑŠÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¸ Ğ±ĞµĞ· NFT; NFT Ğµ Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ĞµĞ½ claim Ğ·Ğ° Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»Ğ¸, ĞºĞ¾Ğ¸Ñ‚Ğ¾ Ğ³Ğ¾ Ğ¸ÑĞºĞ°Ñ‚
- **ĞœĞĞšĞ¡Ğ˜ĞœĞĞ›ĞĞ Ğ¡Ğ˜Ğ“Ğ£Ğ ĞĞĞ¡Ğ¢** â€” rotating QR, device binding, transfer lock ÑĞ»ĞµĞ´ Ğ¿ÑŠÑ€Ğ²Ğ¾ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ, HMAC Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ

### 1.3 ĞŸĞ¾Ğ´Ğ´ÑŠÑ€Ğ¶Ğ°Ğ½Ğ¸ Ğ¼Ñ€ĞµĞ¶Ğ¸

- **Primary:** Polygon (Ğ½Ğ¸ÑĞºĞ¸ gas fees, Ğ±ÑŠÑ€Ğ·Ğ° Ñ„Ğ¸Ğ½Ğ°Ğ»Ğ½Ğ¾ÑÑ‚)
- **Secondary:** BSC, Ethereum (Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ğ¸Ğ·Ğ±Ğ¸Ñ€Ğ° Ğ¿Ñ€Ğ¸ ÑÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ½Ğµ)
- **IPFS:** Ğ¡Ğ¾Ğ±ÑÑ‚Ğ²ĞµĞ½ node Ğ½Ğ° Hetzner VPS (primary + fallback)

---

## 2. SMART CONTRACTS (Solidity 0.8.28)

### 2.1 ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€ĞµĞ½ Ğ¿Ñ€ĞµĞ³Ğ»ĞµĞ´

```
Diamond Proxy v2 (EIP-2535)
â”œâ”€â”€ FactoryFacet v2        â€” Ğ¡ÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ½Ğµ Ğ½Ğ° ÑÑŠĞ±Ğ¸Ñ‚Ğ¸Ñ
â”œâ”€â”€ TreasuryFacet          â€” ĞŸĞ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼ĞµĞ½Ğ¸ Ñ‚Ğ°ĞºÑĞ¸
â””â”€â”€ AdminFacet             â€” Platform management

EventContract v2 (per-event, ĞºĞ»Ğ¾Ğ½Ğ¸Ñ€Ğ°Ğ½)
â”œâ”€â”€ ERC721 Ğ¸Ğ»Ğ¸ ERC1155     â€” NFT Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¸
â”œâ”€â”€ Crypto payment logic   â€” GembaPay protocol Ğ²Ğ³Ñ€Ğ°Ğ´ĞµĞ½
â”œâ”€â”€ Fiat proof minting     â€” Backend-verified mint
â”œâ”€â”€ Ticket lifecycle       â€” activate/lock/transfer control
â””â”€â”€ Event management       â€” cancel/end/metadata

ClaimContract (singleton)
â”œâ”€â”€ Lock NFT Ğ·Ğ° claim      â€” NFT-Ñ‚Ğ°Ñ‚Ğ° Ñ‡Ğ°ĞºĞ°Ñ‚ Ñ‚ÑƒĞº
â”œâ”€â”€ Claim Ñ ĞºĞ¾Ğ´            â€” ĞŸĞ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ» Ğ²Ğ·ĞµĞ¼a NFT
â””â”€â”€ Renounced ownership    â€” ĞĞ¸ĞºĞ¾Ğ¹ Ğ½ÑĞ¼Ğ° ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»
```

### 2.2 EventContract v2 â€” Ğ”ĞµÑ‚Ğ°Ğ¹Ğ»Ğ½Ğ° ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ

```solidity
// ============================================
// STATE VARIABLES
// ============================================

address public owner;              // ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ (Ğ¼Ğ¾Ğ¶Ğµ EOA Ğ¸Ğ»Ğ¸ smart wallet)
address public platform;           // Platform backend address (Ğ·Ğ° fiat mint)
address public treasury;           // PlatformTreasury address
address public claimContract;      // ClaimContract address

string public eventName;
string public eventLocation;
string public eventDate;
string public eventTime;
string public eventDescription;
string public baseTokenURI;        // IPFS base URI

bool public isEventCanceled;
bool public isEventEnded;
bool public saleActive;

uint256 public platformFeeBps;     // 500 = 5%
uint256 public totalMinted;

// ERC721 Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚:
uint256 public maxSupply;
uint256 public price;              // Ğ’ native token (ETH/BNB/MATIC)

// ERC1155 Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚:
struct TicketType {
    string name;                   // "General", "VIP", "Backstage"
    uint256 price;
    uint256 maxSupply;
    uint256 minted;
    bool active;
}
mapping(uint256 => TicketType) public ticketTypes;

// Ticket lifecycle
mapping(uint256 => bool) public ticketActivated;       // Ğ¡Ğ»ĞµĞ´ Ğ¿ÑŠÑ€Ğ²Ğ¾ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ
mapping(uint256 => address) public activatedBy;         // ĞšĞ¾Ğ¹ Ğ³Ğ¾ Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ»
mapping(uint256 => bytes32) public ticketClaimHash;     // Hash Ğ·Ğ° claim

// ============================================
// CRYPTO PAYMENT (GembaPay Protocol)
// ============================================

function buyTicketCrypto(uint256 ticketTypeId) external payable {
    require(saleActive, "Sale not active");
    require(!isEventCanceled, "Event canceled");
    require(!isEventEnded, "Event ended");

    uint256 ticketPrice = _getPrice(ticketTypeId);
    require(msg.value >= ticketPrice, "Insufficient payment");

    // Non-custodial split â€” ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ°Ñ‚Ğ° Ğ’Ğ•Ğ”ĞĞĞ“Ğ Ğ¾Ñ‚Ğ¸Ğ²Ğ°Ñ‚ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ğ¸Ñ‚Ğµ
    uint256 platformFee = (ticketPrice * platformFeeBps) / 10000;
    uint256 organizerAmount = ticketPrice - platformFee;

    // Ğ”Ğ¸Ñ€ĞµĞºÑ‚ĞµĞ½ transfer â€” ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ÑŠÑ‚ ĞĞ• Ğ·Ğ°Ğ´ÑŠÑ€Ğ¶Ğ° ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ°
    (bool sentOrganizer,) = owner.call{value: organizerAmount}("");
    require(sentOrganizer, "Organizer payment failed");

    (bool sentTreasury,) = treasury.call{value: platformFee}("");
    require(sentTreasury, "Treasury payment failed");

    // Refund excess
    if (msg.value > ticketPrice) {
        (bool refunded,) = msg.sender.call{value: msg.value - ticketPrice}("");
        require(refunded, "Refund failed");
    }

    // Mint NFT Ğ² ClaimContract
    uint256 tokenId = _mintToClaimContract(msg.sender, ticketTypeId);

    emit TicketPurchased(msg.sender, tokenId, ticketTypeId, ticketPrice, "crypto");
}

// ============================================
// FIAT PAYMENT (GembaPay webhook â†’ Backend â†’ Ñ‚ÑƒĞº)
// ============================================

function mintWithFiatProof(
    address _buyer,
    uint256 _ticketTypeId,
    bytes32 _paymentHash        // GembaPay payment ID hash
) external onlyPlatform {
    require(saleActive, "Sale not active");
    require(!isEventCanceled, "Event canceled");

    uint256 tokenId = _mintToClaimContract(_buyer, _ticketTypeId);

    emit TicketPurchased(_buyer, tokenId, _ticketTypeId, 0, "fiat");
    emit FiatPaymentRecorded(_paymentHash, tokenId);
}

// ============================================
// MINT TO CLAIM CONTRACT (internal)
// ============================================

function _mintToClaimContract(
    address _buyer,
    uint256 _ticketTypeId
) internal returns (uint256 tokenId) {
    _validateSupply(_ticketTypeId);

    tokenId = ++totalMinted;

    // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ¼Ğµ claim hash
    bytes32 claimHash = keccak256(abi.encodePacked(
        tokenId, _buyer, block.timestamp, blockhash(block.number - 1)
    ));
    ticketClaimHash[tokenId] = claimHash;

    // Mint NFT Ğ² ClaimContract (Ğ½Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ½Ğ° buyer)
    _safeMint(address(claimContract), tokenId);

    // Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ¼Ğµ Ğ² ClaimContract
    IClaimContract(claimContract).lockForClaim(claimHash, tokenId, _buyer);
}

// ============================================
// TICKET LIFECYCLE
// ============================================

// Ğ˜Ğ·Ğ²Ğ¸ĞºĞ²Ğ° ÑĞµ Ğ¾Ñ‚ backend Ğ¿Ñ€Ğ¸ Ğ¿ÑŠÑ€Ğ²Ğ¾ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ
function activateTicket(uint256 _tokenId) external onlyPlatform {
    require(!ticketActivated[_tokenId], "Already activated");
    ticketActivated[_tokenId] = true;

    // ĞĞºĞ¾ Ğµ claim-Ğ½Ğ°Ñ‚, Ğ·Ğ°Ğ¿Ğ¸ÑĞ²Ğ°Ğ¼Ğµ owner-Ğ°; Ğ°ĞºĞ¾ Ğ½Ğµ â€” buyer Ğ¾Ñ‚ ClaimContract
    address ticketHolder = _getEffectiveOwner(_tokenId);
    activatedBy[_tokenId] = ticketHolder;

    emit TicketActivated(_tokenId, ticketHolder);
}

// Transfer control hook
function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
) internal override {
    // Mint (from == 0) Ğµ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¸ OK
    if (from == address(0)) return;

    // Ğ¡Ğ»ĞµĞ´ ĞºÑ€Ğ°Ñ Ğ½Ğ° ÑÑŠĞ±Ğ¸Ñ‚Ğ¸ĞµÑ‚Ğ¾ â€” ÑĞ²Ğ¾Ğ±Ğ¾Ğ´ĞµĞ½ transfer
    if (isEventEnded) return;

    // Ğ¡Ğ»ĞµĞ´ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ½Ğµ â€” Ğ‘Ğ›ĞĞšĞ˜Ğ ĞĞ transfer
    require(!ticketActivated[tokenId], "Ticket activated - transfer locked");
}

// ============================================
// EVENT MANAGEMENT
// ============================================

function cancelEvent() external onlyOwner {
    require(!isEventEnded, "Event already ended");
    isEventCanceled = true;
    saleActive = false;
    emit EventCanceled(block.timestamp);
    // Fiat refunds â†’ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ñ‡Ñ€ĞµĞ· GembaPay/Stripe
    // Crypto refunds â†’ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ñ€ÑŠÑ‡Ğ½Ğ¾ (Ğ½Ğµ Ğ´ÑŠÑ€Ğ¶Ğ¸Ğ¼ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ°)
}

function endEvent() external onlyOwner {
    require(!isEventCanceled, "Event is canceled");
    isEventEnded = true;
    saleActive = false;
    emit EventEnded(block.timestamp);
    // ĞÑ‚ĞºĞ»ÑÑ‡Ğ²Ğ° NFT transfers Ğ·Ğ° Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµĞ½ Ğ¿Ğ°Ğ·Ğ°Ñ€
}

function setEventDetails(...) external onlyOwner { ... }
function toggleSale() external onlyOwner { ... }
function setBaseURI(string calldata _uri) external onlyOwner { ... }

// ============================================
// MODIFIERS
// ============================================

modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}

modifier onlyPlatform() {
    require(msg.sender == platform, "Not platform");
    _;
}
```

### 2.3 ClaimContract â€” Ğ”ĞµÑ‚Ğ°Ğ¹Ğ»Ğ½Ğ° ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ

```solidity
// ============================================
// CLAIM CONTRACT â€” Autonomous NFT Holding
// ============================================
// Owner: address(0) ÑĞ»ĞµĞ´ deployment (renounced)
// ĞĞ¸ĞºĞ¾Ğ¹ Ğ½ÑĞ¼Ğ° ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ» â€” ÑĞ°Ğ¼Ğ¾ ĞºĞ¾Ğ´

struct ClaimData {
    address eventContract;     // ĞšĞ¾Ğ¹ event contract
    uint256 tokenId;           // ĞšĞ¾Ğ¹ token
    address buyer;             // ĞšĞ¾Ğ¹ Ğµ ĞºÑƒĞ¿Ğ¸Ğ» (Ğ·Ğ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ)
    bool claimed;              // Ğ’ĞµÑ‡Ğµ claim-Ğ½Ğ°Ñ‚ Ğ»Ğ¸ Ğµ
    uint256 createdAt;         // ĞšĞ¾Ğ³Ğ° Ğµ ÑÑŠĞ·Ğ´Ğ°Ğ´ĞµĞ½
}

mapping(bytes32 => ClaimData) public claims;

// Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ½Ğµ Ğ½Ğ° claim (ÑĞ°Ğ¼Ğ¾ Ğ¾Ñ‚ event contracts)
function lockForClaim(
    bytes32 _claimHash,
    uint256 _tokenId,
    address _buyer
) external {
    // Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ: caller Ñ‚Ñ€ÑĞ±Ğ²Ğ° Ğ´Ğ° Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ½ event contract
    require(registeredEvents[msg.sender], "Not registered event");
    require(claims[_claimHash].eventContract == address(0), "Claim exists");

    claims[_claimHash] = ClaimData({
        eventContract: msg.sender,
        tokenId: _tokenId,
        buyer: _buyer,
        claimed: false,
        createdAt: block.timestamp
    });

    emit ClaimLocked(_claimHash, msg.sender, _tokenId, _buyer);
}

// ĞŸĞ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ» claim-Ğ²Ğ° NFT (Ñ‚Ñ€ÑĞ±Ğ²Ğ° Ğ´Ğ° Ğ·Ğ½Ğ°Ğµ claimCode)
function claim(
    string calldata _claimCode,
    address _destinationWallet
) external {
    bytes32 claimHash = keccak256(abi.encodePacked(_claimCode));
    ClaimData storage data = claims[claimHash];

    require(data.eventContract != address(0), "Invalid claim code");
    require(!data.claimed, "Already claimed");

    data.claimed = true;

    // Transfer NFT Ğ¾Ñ‚ ClaimContract â†’ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»ÑĞºĞ¸ wallet
    IERC721(data.eventContract).transferFrom(
        address(this),
        _destinationWallet,
        data.tokenId
    );

    emit NFTClaimed(claimHash, _destinationWallet, data.tokenId);
}

// Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ½Ğµ Ğ½Ğ° Ğ½Ğ¾Ğ² event contract (Ğ¾Ñ‚ Factory)
function registerEvent(address _eventContract) external onlyFactory {
    registeredEvents[_eventContract] = true;
}

// Transfer claim Ğ½Ğ° Ğ½Ğ¾Ğ² buyer (Ğ¿Ñ€ĞµĞ´Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ½Ğµ)
function transferClaim(
    bytes32 _claimHash,
    address _newBuyer
) external {
    ClaimData storage data = claims[_claimHash];
    require(data.buyer == msg.sender || msg.sender == data.eventContract,
            "Not authorized");
    require(!data.claimed, "Already claimed");

    data.buyer = _newBuyer;
    emit ClaimTransferred(_claimHash, msg.sender, _newBuyer);
}
```

### 2.4 FactoryFacet v2

```solidity
function createEvent(
    bytes calldata _initData,
    uint256 _eventType        // 0 = ERC721, 1 = ERC1155
) external payable returns (address eventAddress) {
    // ĞŸĞ»Ğ°Ñ‰Ğ°Ğ½Ğµ Ğ·Ğ° ÑÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ½Ğµ: GembaPay (fiat) Ğ¸Ğ»Ğ¸ native token
    // ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ½Ğ° Ñ‚Ğ°ĞºÑĞ° Ğ¿Ğ¾ĞºÑ€Ğ¸Ğ²Ğ° gas + platform fee
    require(msg.value >= createEventFee, "Insufficient fee");

    // Deploy Ñ‡Ñ€ĞµĞ· CREATE2 (deterministic address)
    bytes32 salt = keccak256(abi.encodePacked(msg.sender, block.timestamp));

    if (_eventType == 0) {
        eventAddress = Clones.cloneDeterministic(erc721Template, salt);
    } else {
        eventAddress = Clones.cloneDeterministic(erc1155Template, salt);
    }

    // Initialize
    IEventContract(eventAddress).initialize(_initData, msg.sender, platform, treasury, claimContract);

    // Register Ğ² ClaimContract
    IClaimContract(claimContract).registerEvent(eventAddress);

    // Fee â†’ Treasury
    (bool sent,) = treasury.call{value: msg.value}("");
    require(sent, "Fee transfer failed");

    allEvents.push(eventAddress);
    emit EventCreated(eventAddress, msg.sender, _eventType);
}

// Ğ—Ğ° fiat Ğ¿Ğ»Ğ°Ñ‰Ğ°Ğ½Ğµ Ğ½Ğ° ÑÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ½Ğµ (backend Ğ²Ğ¸ĞºĞ° ÑĞ»ĞµĞ´ GembaPay Ğ¿Ğ¾Ñ‚Ğ²ÑŠÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ)
function createEventWithFiatProof(
    bytes calldata _initData,
    uint256 _eventType,
    address _organizer,
    bytes32 _paymentHash
) external onlyPlatform returns (address) {
    // Ğ¡ÑŠÑ‰Ğ°Ñ‚Ğ° Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°, Ğ½Ğ¾ Ğ±ĞµĞ· msg.value
    // Gas ÑĞµ Ğ¿Ğ¾ĞºÑ€Ğ¸Ğ²Ğ° Ğ¾Ñ‚ platform treasury
}
```

### 2.5 PlatformTreasury

```solidity
// Ğ¡ÑŠĞ±Ğ¸Ñ€Ğ° Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼ĞµĞ½Ğ¸ Ñ‚Ğ°ĞºÑĞ¸
// Multisig ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ (3-of-3 Ğ¸Ğ»Ğ¸ 2-of-3)
// emergencyWithdraw Ñ timelock
// ĞŸĞ¾ĞºÑ€Ğ¸Ğ²Ğ° gas Ğ·Ğ° fiat Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ (createEvent, mint)

receive() external payable {
    emit FundsReceived(msg.sender, msg.value);
}

function withdraw(address _to, uint256 _amount) external onlyMultisig {
    (bool sent,) = _to.call{value: _amount}("");
    require(sent, "Withdraw failed");
}
```

### 2.6 ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ¸ â€” ĞĞ±Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ

| ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ | LOC (est.) | Ğ Ğ¾Ğ»Ñ |
|----------|-----------|------|
| EventContract721 v2 | ~350 | ERC721 + payments + lifecycle |
| EventContract1155 v2 | ~400 | ERC1155 + ticket types + payments + lifecycle |
| ClaimContract | ~150 | Autonomous NFT holding + claim |
| FactoryFacet v2 | ~200 | Event deployment + registration |
| TreasuryFacet | ~100 | Fee collection + multisig withdraw |
| AdminFacet | ~80 | Platform settings |
| **ĞĞ±Ñ‰Ğ¾** | **~1280** | **vs. ÑĞµĞ³Ğ°ÑˆĞ½Ğ¸Ñ‚Ğµ ~4150 LOC** |

ĞĞ°Ğ¼Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ ~4150 â†’ ~1280 LOC (69% Ğ¿Ğ¾-Ğ¼Ğ°Ğ»ĞºĞ¾ ĞºĞ¾Ğ´, Ğ¿Ğ¾-Ğ¼Ğ°Ğ»ĞºĞ¾ attack surface).

### 2.7 ĞšĞ°ĞºĞ²Ğ¾ ĞĞ• Ğ²ĞºĞ»ÑÑ‡Ğ²Ğ°Ğ¼Ğµ (vs. v1)

- âŒ Validator/Oracle contracts â€” GembaPay Ğ·Ğ°Ğ¼ĞµÑÑ‚Ğ²Ğ°
- âŒ QRModule on-chain â€” off-chain ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ (Ğ¿Ğ¾-Ğ±ÑŠÑ€Ğ·Ğ¾, Ğ±ĞµĞ·Ğ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾)
- âŒ AdminModule as separate contract â€” Ğ²Ğ³Ñ€Ğ°Ğ´ĞµĞ½ Ğ² EventContract
- âŒ MintModule as separate contract â€” Ğ²Ğ³Ñ€Ğ°Ğ´ĞµĞ½ Ğ² EventContract
- âŒ ViewModule â€” frontend Ñ‡ĞµÑ‚Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ¾Ñ‚ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°
- âŒ balanceThreshold â€” Ğ½Ğµ ÑĞµ Ğ½Ğ°Ñ‚Ñ€ÑƒĞ¿Ğ²Ğ° Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ² ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°
- âŒ Minter wallet management â€” Ğ½ÑĞ¼Ğ° custodial wallets

---

## 3. BACKEND (Node.js + Express)

### 3.1 ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€ĞµĞ½ Ğ¿Ñ€ĞµĞ³Ğ»ĞµĞ´

```
src/
â”œâ”€â”€ app.js                          â€” Express setup, CORS, CSP
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ auth.js                     â€” JWT auth (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ security.js                 â€” Rate limiting, logging (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ validation.js               â€” Input validation (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â””â”€â”€ hmac.js                     â€” ĞĞĞ’: HMAC Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ·Ğ° QR
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth.js                     â€” Login/register (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ events.js                   â€” Event CRUD (ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞ)
â”‚   â”œâ”€â”€ tickets.js                  â€” Ticket management (ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞ)
â”‚   â”œâ”€â”€ scanner.js                  â€” Scan verification (ĞŸĞ Ğ•ĞĞĞŸĞ˜Ğ¡ĞĞ)
â”‚   â”œâ”€â”€ claims.js                   â€” ĞĞĞ’: NFT claim endpoints
â”‚   â”œâ”€â”€ webhooks.js                 â€” ĞĞĞ’: GembaPay webhooks
â”‚   â””â”€â”€ organizer.js                â€” ĞĞĞ’: Organizer management
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ userAuth.js             â€” User auth (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”‚   â””â”€â”€ googleAuth.js           â€” Google OAuth (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ blockchain.js               â€” Contract interactions (ĞŸĞ Ğ•ĞĞĞŸĞ˜Ğ¡ĞĞ)
â”‚   â”œâ”€â”€ ipfs.js                     â€” IPFS client (Ğ—ĞĞŸĞĞ—Ğ•Ğ, Ğ´Ğ¾Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞµĞ½)
â”‚   â”œâ”€â”€ ticketGenerator.js          â€” Ticket images (ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞ Ğ·Ğ° 3-page)
â”‚   â”œâ”€â”€ notificationService.js      â€” Email (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ queue.js                    â€” Bull queues (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ redis.js                    â€” Redis cache (Ğ—ĞĞŸĞĞ—Ğ•Ğ)
â”‚   â”œâ”€â”€ database.js                 â€” DB pool (Ğ—ĞĞŸĞĞ—Ğ•Ğ, Ğ½Ğ¾Ğ²Ğ° schema)
â”‚   â”œâ”€â”€ scannerService.js           â€” ĞĞĞ’: Scan logic + HMAC + device binding
â”‚   â”œâ”€â”€ claimService.js             â€” ĞĞĞ’: Claim code management
â”‚   â”œâ”€â”€ transferService.js          â€” ĞĞĞ’: Ticket transfer logic
â”‚   â”œâ”€â”€ metadataService.js          â€” ĞĞĞ’: Dynamic NFT metadata
â”‚   â””â”€â”€ gembapay/
â”‚       â”œâ”€â”€ webhookHandler.js       â€” ĞĞĞ’: Process GembaPay webhooks
â”‚       â””â”€â”€ paymentVerifier.js      â€” ĞĞĞ’: Verify payment proofs
â””â”€â”€ utils/
    â”œâ”€â”€ hmac.js                     â€” ĞĞĞ’: HMAC generation/verification
    â”œâ”€â”€ claimCodes.js               â€” ĞĞĞ’: Secure claim code generation
    â””â”€â”€ deviceFingerprint.js        â€” ĞĞĞ’: Device binding logic
```

### 3.2 ĞšĞ¾Ğ´ Ğ·Ğ° Ğ·Ğ°Ğ¿Ğ°Ğ·Ğ²Ğ°Ğ½Ğµ Ğ¾Ñ‚ v1

| Ğ¤Ğ°Ğ¹Ğ» | Ğ ĞµĞ´Ğ¾Ğ²Ğµ | ĞŸÑ€Ğ¾Ğ¼ĞµĞ½Ğ¸ |
|------|--------|---------|
| middleware/auth.js | 439 | Ğ‘ĞµĞ· Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ğ¸ |
| middleware/security.js | 313 | Ğ‘ĞµĞ· Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ğ¸ |
| services/auth/userAuth.js | 424 | ĞœĞ°Ñ…Ğ°Ğ¼Ğµ wallet generation Ğ¿Ğ¾Ğ»ĞµÑ‚Ğ°Ñ‚Ğ° |
| services/ipfs.js | 304 | Ğ”Ğ¾Ğ±Ğ°Ğ²ÑĞ¼Ğµ 3-page upload logic |
| services/ticketGenerator.js | 277 | ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ°Ğ¼Ğµ Ğ·Ğ° 3-page Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½ |
| services/notificationService.js | 402 | Ğ”Ğ¾Ğ±Ğ°Ğ²ÑĞ¼Ğµ claim code Ğ² email-Ğ¸Ñ‚Ğµ |
| services/queue.js | 331 | Ğ”Ğ¾Ğ±Ğ°Ğ²ÑĞ¼Ğµ Ğ½Ğ¾Ğ²Ğ¸ queue types |
| services/database.js | 468 | ĞĞ¾Ğ²Ğ° schema migration |
| **ĞĞ±Ñ‰Ğ¾ Ğ·Ğ°Ğ¿Ğ°Ğ·ĞµĞ½** | **~2958** | |

### 3.3 ĞšĞ¾Ğ´ Ğ·Ğ° ĞœĞĞ¥ĞĞĞ• Ğ¾Ñ‚ v1

| Ğ¤Ğ°Ğ¹Ğ» | ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° |
|------|---------|
| services/auth/custodialWallet.js | CUSTODY â€” Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ° PK |
| services/eventWalletManager.js | CUSTODY â€” minter wallets |
| services/ticketMinter.js | Ğ—Ğ°Ğ²Ğ¸ÑĞ¸ Ğ¾Ñ‚ custodial wallets |
| services/payments/stripe.js | Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½ Ğ¾Ñ‚ GembaPay |
| services/payments/paypal.js | Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½ Ğ¾Ñ‚ GembaPay |
| services/payments/paymentProcessor.js | Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½ Ğ¾Ñ‚ GembaPay |
| routes/factory.js | ĞĞ¾Ğ²Ğ° factory Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° |
| routes/blockchain.js | ĞŸÑ€ĞµĞ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½ |
| routes/payments.js | Ğ—Ğ°Ğ¼ĞµĞ½ĞµĞ½ Ğ¾Ñ‚ GembaPay webhooks |
| utils/encryption.js | ĞÑĞ¼Ğ° PK Ğ·Ğ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¸Ñ€Ğ°Ğ½Ğµ |
| utils/keyDerivation.js | ĞÑĞ¼Ğ° PK Ğ·Ğ° derivation |

### 3.4 ĞĞ¾Ğ²Ğ¸ services â€” Ğ”ĞµÑ‚Ğ°Ğ¹Ğ»Ğ½Ğ° ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ

#### 3.4.1 scannerService.js â€” Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ Ñ rotating QR

```javascript
class ScannerService {

  // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ° rotating QR Ğ´Ğ°Ğ½Ğ½Ğ¸ (Ğ½Ğ° Ğ²ÑĞµĞºĞ¸ 30 ÑĞµĞº)
  generateRotatingQR(serialNumber) {
    const timestamp = Math.floor(Date.now() / 30000) * 30000; // 30-sec window
    const hmacSecret = this.getTicketHmacSecret(serialNumber);
    const signature = crypto
      .createHmac('sha256', hmacSecret)
      .update(`${serialNumber}:${timestamp}`)
      .digest('hex')
      .substring(0, 16);

    return {
      sn: serialNumber,
      ts: timestamp,
      sig: signature
    };
  }

  // Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ° QR Ğ¾Ñ‚ ÑĞºĞµĞ½ĞµÑ€
  async verifyScan(qrData, scannerInfo) {
    const { sn, ts, sig } = qrData;

    // 1. Timestamp Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° (Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ‚Ğµ 60 ÑĞµĞº)
    const now = Date.now();
    if (Math.abs(now - ts) > 60000) {
      return { valid: false, reason: 'QR code expired' };
    }

    // 2. HMAC Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
    const hmacSecret = await this.getTicketHmacSecret(sn);
    const expectedSig = crypto
      .createHmac('sha256', hmacSecret)
      .update(`${sn}:${ts}`)
      .digest('hex')
      .substring(0, 16);

    if (sig !== expectedSig) {
      return { valid: false, reason: 'Invalid QR signature' };
    }

    // 3. Ticket lookup
    const ticket = await db.query(
      'SELECT * FROM tickets WHERE serial_number = $1', [sn]
    );
    if (!ticket) return { valid: false, reason: 'Ticket not found' };

    // 4. Scanner Ğ¾Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ° Ñ‚Ğ¾Ğ·Ğ¸ event
    const scanner = await db.query(
      'SELECT * FROM scanners WHERE id = $1 AND event_id = $2 AND is_active = true',
      [scannerInfo.scannerId, ticket.event_id]
    );
    if (!scanner) return { valid: false, reason: 'Scanner not authorized' };

    // 5. Ticket type Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ° Ğ·Ğ¾Ğ½Ğ°
    if (scannerInfo.zoneTokenType !== undefined) {
      if (ticket.ticket_type_id < scannerInfo.zoneTokenType) {
        return { valid: false, reason: 'Insufficient access level' };
      }
    }

    // 6. First scan â†’ ACTIVATE + LOCK
    if (!ticket.is_activated) {
      await this.activateTicket(ticket);
      return { valid: true, action: 'ENTRY', firstScan: true };
    }

    // 7. Ğ’ĞµÑ‡Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ½ â†’ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ°Ğ»Ğ¸ Ğµ ÑÑŠÑ‰Ğ¸ÑÑ‚ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»
    if (ticket.locked_to_user !== scannerInfo.currentUserId) {
      return { valid: false, reason: 'Ticket activated by another user' };
    }

    // 8. Entry/Exit toggle
    const lastScan = await db.query(
      'SELECT scan_type FROM scan_logs WHERE ticket_id = $1 ORDER BY scan_time DESC LIMIT 1',
      [ticket.id]
    );
    const nextAction = (!lastScan || lastScan.scan_type === 'exit') ? 'ENTRY' : 'EXIT';

    return { valid: true, action: nextAction, firstScan: false };
  }

  // ĞĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ½Ğµ Ğ½Ğ° Ğ±Ğ¸Ğ»ĞµÑ‚ (Ğ¿ÑŠÑ€Ğ²Ğ¾ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ)
  async activateTicket(ticket) {
    await db.query(`
      UPDATE tickets SET
        is_activated = true,
        locked_to_user = $1,
        locked_to_device = $2,
        activated_at = NOW()
      WHERE id = $3
    `, [ticket.owner_user_id, currentDeviceHash, ticket.id]);

    // On-chain activation (Ğ°ĞºĞ¾ Ğ¸Ğ¼Ğ° NFT)
    if (ticket.token_id) {
      await blockchain.activateTicket(ticket.event_contract, ticket.token_id);
    }

    // Update NFT metadata â€” Ñ†Ğ²ÑÑ‚ ÑÑ‚Ğ°Ğ²Ğ° Ğ—Ğ•Ğ›Ğ•Ğ
    await metadataService.updateTicketVisualState(ticket.id, 'INSIDE', 'green');
  }
}
```

#### 3.4.2 transferService.js â€” ĞŸÑ€ĞµÑ…Ğ²ÑŠÑ€Ğ»ÑĞ½Ğµ Ğ½Ğ° Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¸

```javascript
class TransferService {

  async transferTicket(serialNumber, fromUserId, recipientEmail) {
    const ticket = await db.query(
      'SELECT * FROM tickets WHERE serial_number = $1 AND owner_user_id = $2',
      [serialNumber, fromUserId]
    );

    // Ğ‘Ğ›ĞĞšĞ˜Ğ ĞĞ™ Ğ°ĞºĞ¾ Ğµ Ğ²ĞµÑ‡Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°Ğ½
    if (ticket.is_activated) {
      throw new Error('Ticket is activated and cannot be transferred');
    }

    // ĞĞ°Ğ¼ĞµÑ€Ğ¸ Ğ¸Ğ»Ğ¸ ÑÑŠĞ·Ğ´Ğ°Ğ¹ recipient user
    let recipient = await db.query(
      'SELECT * FROM users WHERE email = $1', [recipientEmail]
    );
    if (!recipient) {
      recipient = await userAuth.createPendingUser(recipientEmail);
    }

    // Ğ ĞµĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ¹ security tokens
    const newAuthToken = secureRandom.generate(32);
    const newHmacSecret = secureRandom.generate(32);

    await db.query(`
      UPDATE tickets SET
        owner_user_id = $1,
        auth_token = $2,
        hmac_secret = $3,
        device_hash = NULL,
        transferred_at = NOW()
      WHERE id = $4
    `, [recipient.id, newAuthToken, newHmacSecret, ticket.id]);

    // Log transfer
    await db.query(`
      INSERT INTO transfer_log (ticket_id, from_user_id, to_user_id, transferred_at)
      VALUES ($1, $2, $3, NOW())
    `, [ticket.id, fromUserId, recipient.id]);

    // On-chain transfer Ğ°ĞºĞ¾ Ğµ claim-Ğ½Ğ°Ñ‚ NFT
    if (ticket.claimed_by) {
      await blockchain.transferClaimOwnership(ticket.claim_hash, recipient.wallet_address);
    }

    // Ğ˜Ğ·Ğ¿Ñ€Ğ°Ñ‚Ğ¸ emails
    await notifications.sendTicketReceivedEmail(recipient, ticket);
    await notifications.sendTicketTransferredEmail(fromUserId, recipientEmail, ticket);

    return { success: true };
  }
}
```

#### 3.4.3 metadataService.js â€” Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡Ğ½Ğ° NFT metadata

```javascript
class MetadataService {

  // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ° 3-page NFT metadata
  async generateEventMetadata(eventId, tokenId) {
    const event = await db.query('SELECT * FROM events WHERE id = $1', [eventId]);
    const ticket = await db.query(
      'SELECT * FROM tickets WHERE event_id = $1 AND token_id = $2',
      [eventId, tokenId]
    );

    // Page 1: Poster (ĞºĞ°Ñ‡ĞµĞ½ Ğ¾Ñ‚ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°)
    const posterCID = event.poster_ipfs_cid;

    // Page 2: Event Info (Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ½)
    const infoImage = await ticketGenerator.generateInfoPage(event, ticket);
    const infoCID = await ipfs.addBuffer(infoImage);

    // Page 3: QR Code (Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµĞ½ â€” animated HTML)
    const qrViewerHTML = this.generateQRViewerHTML(ticket.serial_number, event);
    const qrCID = await ipfs.addBuffer(Buffer.from(qrViewerHTML));

    // ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞ¼Ğµ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ½Ğ¾Ñ‚Ğ¾ ÑÑŠÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    const visualState = await this.getVisualState(ticket);

    const metadata = {
      name: `${event.event_name} â€” ${ticket.ticket_type_name} #${tokenId}`,
      description: `${event.event_name} | ${event.event_date} | ${event.location}`,
      image: `ipfs://${posterCID}`,
      animation_url: `ipfs://${qrCID}`,   // Animated HTML viewer
      external_url: `https://tickets.gembapay.com/ticket/${ticket.serial_number}`,
      attributes: [
        { trait_type: "Event", value: event.event_name },
        { trait_type: "Date", value: event.event_date },
        { trait_type: "Location", value: event.location },
        { trait_type: "Ticket Type", value: ticket.ticket_type_name },
        { trait_type: "Zone Access", value: ticket.zone_name },
        { trait_type: "Status", value: visualState.status },
        { trait_type: "Serial", value: ticket.serial_number }
      ],
      properties: {
        pages: [
          { name: "Event Poster", image: `ipfs://${posterCID}` },
          { name: "Ticket Info", image: `ipfs://${infoCID}` },
          { name: "Entry QR", animation_url: `ipfs://${qrCID}` }
        ],
        visual_state: visualState
      }
    };

    // Upload metadata JSON Ğ½Ğ° IPFS
    const metadataCID = await ipfs.addJSON(metadata);
    return metadataCID;
  }

  // Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµĞ½ API endpoint Ğ·Ğ° metadata (fallback Ğ°ĞºĞ¾ IPFS Ğµ Ğ±Ğ°Ğ²ĞµĞ½)
  // GET /api/v1/metadata/:eventAddress/:tokenId.json
  async serveMetadata(eventAddress, tokenId) {
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ²Ğ° cache, Ğ¿Ğ¾ÑĞ»Ğµ DB, Ğ¿Ğ¾ÑĞ»Ğµ IPFS
    // Ğ’Ñ€ÑŠÑ‰Ğ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»Ğ½Ğ° metadata Ñ Ñ‚ĞµĞºÑƒÑ‰Ğ¾ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ½Ğ¾ ÑÑŠÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
  }

  // Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ½Ğ¸ ÑÑŠÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ·Ğ° "ÑĞ²ĞµÑ‚ĞµÑ‰Ğ¸Ñ‚Ğµ" NFT
  async getVisualState(ticket) {
    if (!ticket.is_activated) {
      return { status: "Ready", color: "#FFFFFF", glow: "none", animation: "none" };
    }

    const lastScan = await db.query(
      'SELECT * FROM scan_logs WHERE ticket_id = $1 ORDER BY scan_time DESC LIMIT 1',
      [ticket.id]
    );

    const event = await db.query('SELECT * FROM events WHERE id = $1', [ticket.event_id]);

    if (event.is_event_ended) {
      return {
        status: "Event Attended âœ“",
        color: "#1a1a1a",
        glow: "rainbow",
        animation: "hologram",
        badge: "Collector's Edition"
      };
    }

    if (lastScan?.scan_type === 'exit') {
      return { status: "OUTSIDE", color: "#3B82F6", glow: "blue-pulse", animation: "breathe" };
    }

    // Ğ’ÑŠÑ‚Ñ€Ğµ â€” Ğ·Ğ°Ğ²Ğ¸ÑĞ¸ Ğ¾Ñ‚ Ğ·Ğ¾Ğ½Ğ°Ñ‚Ğ°
    const zone = lastScan?.zone || 'general';
    const zoneColors = {
      general:   { status: "INSIDE", color: "#22C55E", glow: "green-pulse" },
      vip:       { status: "VIP ZONE", color: "#F59E0B", glow: "gold-pulse" },
      backstage: { status: "BACKSTAGE", color: "#EF4444", glow: "red-pulse" },
      allaccess: { status: "ALL ACCESS", color: "#8B5CF6", glow: "rainbow-pulse" }
    };

    return { ...zoneColors[zone], animation: "pulse" };
  }
}
```

#### 3.4.4 GembaPay Webhook Handler

```javascript
// routes/webhooks.js
router.post('/gembapay', webhookSignatureVerify, async (req, res) => {
  const { event, data } = req.body;

  switch (event) {
    case 'payment.completed':
      // Fiat Ğ¸Ğ»Ğ¸ crypto Ğ¿Ğ»Ğ°Ñ‰Ğ°Ğ½Ğµ Ğ¿Ğ¾Ñ‚Ğ²ÑŠÑ€Ğ´ĞµĞ½Ğ¾
      const { paymentId, eventId, ticketTypeId, buyerEmail, amount } = data;

      // 1. Ğ¡ÑŠĞ·Ğ´Ğ°Ğ¹ ticket Ğ² DB
      const ticket = await ticketService.createTicket(eventId, ticketTypeId, buyerEmail);

      // 2. Mint NFT Ğ² ClaimContract Ñ‡Ñ€ĞµĞ· backend wallet
      const paymentHash = ethers.keccak256(ethers.toUtf8Bytes(paymentId));
      const tx = await blockchain.mintWithFiatProof(
        ticket.event_contract,
        ticket.owner_address || claimContract.address,
        ticketTypeId,
        paymentHash
      );

      // 3. Upload metadata Ğ½Ğ° IPFS
      const metadataCID = await metadataService.generateEventMetadata(eventId, ticket.token_id);

      // 4. Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ¹ claim ĞºĞ¾Ğ´
      const claimCode = await claimService.generateClaimCode(ticket);

      // 5. Ğ˜Ğ·Ğ¿Ñ€Ğ°Ñ‚Ğ¸ email Ñ QR Ğ»Ğ¸Ğ½Ğº + claim ĞºĞ¾Ğ´
      await notifications.sendTicketPurchasedEmail(buyerEmail, ticket, claimCode);

      break;

    case 'payment.failed':
      // Ğ›Ğ¾Ğ³Ğ²Ğ°Ğ¹ failed payment
      break;

    case 'payment.refunded':
      // ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» refund
      // Update ticket status, notify buyer
      break;

    case 'merchant.event_creation_paid':
      // ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ Ğµ Ğ¿Ğ»Ğ°Ñ‚Ğ¸Ğ» Ğ·Ğ° ÑÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ½Ğµ Ğ½Ğ° ÑÑŠĞ±Ğ¸Ñ‚Ğ¸Ğµ
      // Deploy EventContract
      break;
  }

  res.json({ received: true });
});
```

### 3.5 API Endpoints â€” ĞŸÑŠĞ»ĞµĞ½ ÑĞ¿Ğ¸ÑÑŠĞº

```
AUTH (Ğ—ĞĞŸĞĞ—Ğ•ĞĞ˜):
  POST   /api/v1/auth/register        â€” Email + password registration
  POST   /api/v1/auth/login           â€” Login â†’ JWT
  POST   /api/v1/auth/google          â€” Google OAuth
  POST   /api/v1/auth/verify-email    â€” Email verification
  POST   /api/v1/auth/refresh         â€” Refresh JWT

EVENTS (ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞĞ˜):
  POST   /api/v1/events               â€” Ğ¡ÑŠĞ·Ğ´Ğ°Ğ¹ event (trigger deploy)
  GET    /api/v1/events               â€” Ğ¡Ğ¿Ğ¸ÑÑŠĞº events (Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡ĞµĞ½)
  GET    /api/v1/events/:id           â€” Event Ğ´ĞµÑ‚Ğ°Ğ¹Ğ»Ğ¸
  PUT    /api/v1/events/:id           â€” Update event (organizer only)
  POST   /api/v1/events/:id/cancel    â€” ĞÑ‚Ğ¼ĞµĞ½Ğ¸ event
  POST   /api/v1/events/:id/end       â€” ĞŸÑ€Ğ¸ĞºĞ»ÑÑ‡Ğ¸ event
  GET    /api/v1/events/:id/stats     â€” Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ (organizer only)

TICKETS (ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞĞ˜):
  GET    /api/v1/tickets/my           â€” ĞœĞ¾Ğ¸Ñ‚Ğµ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¸
  GET    /api/v1/tickets/:serial      â€” Ticket Ğ´ĞµÑ‚Ğ°Ğ¹Ğ»Ğ¸
  GET    /api/v1/tickets/:serial/qr   â€” Live rotating QR Ğ´Ğ°Ğ½Ğ½Ğ¸
  POST   /api/v1/tickets/:serial/transfer â€” ĞŸÑ€ĞµÑ…Ğ²ÑŠÑ€Ğ»Ğ¸ Ğ±Ğ¸Ğ»ĞµÑ‚
  GET    /api/v1/tickets/:serial/live â€” Live ticket page Ğ´Ğ°Ğ½Ğ½Ğ¸

SCANNER (ĞŸĞ Ğ•ĞĞĞŸĞ˜Ğ¡ĞĞ):
  POST   /api/v1/scanner/scan         â€” Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ¹ QR
  POST   /api/v1/scanner/register     â€” Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ¹ ÑĞºĞµĞ½ĞµÑ€ Ğ·Ğ° event
  GET    /api/v1/scanner/:id/stats    â€” Scanner ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
  GET    /api/v1/scanner/event/:eventId/live â€” Live scan feed (WebSocket)

CLAIMS (ĞĞĞ’):
  POST   /api/v1/claims/claim         â€” Claim NFT Ñ ĞºĞ¾Ğ´
  GET    /api/v1/claims/:serial/status â€” Claim status

METADATA (ĞĞĞ’):
  GET    /api/v1/metadata/:address/:tokenId.json â€” NFT metadata
  GET    /api/v1/metadata/:address/:tokenId/visual â€” Visual state API

WEBHOOKS (ĞĞĞ’):
  POST   /api/v1/webhooks/gembapay    â€” GembaPay payment events

ORGANIZER (ĞĞĞ’):
  POST   /api/v1/organizer/register   â€” Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ°Ğ¹ ÑĞµ ĞºĞ°Ñ‚Ğ¾ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€
  GET    /api/v1/organizer/events     â€” ĞœĞ¾Ğ¸Ñ‚Ğµ ÑÑŠĞ±Ğ¸Ñ‚Ğ¸Ñ
  POST   /api/v1/organizer/upload-poster â€” Upload poster image
```

---

## 4. DATABASE (PostgreSQL)

### 4.1 ĞĞ¾Ğ²Ğ° ÑÑ…ĞµĞ¼Ğ°

```sql
-- ============================================
-- Ğ—ĞĞŸĞĞ—Ğ•ĞĞ˜ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ˜ (Ñ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)
-- ============================================

-- USERS â€” Ğ¼Ğ°Ñ…Ğ°Ğ¼Ğµ custodial wallet Ğ¿Ğ¾Ğ»ĞµÑ‚Ğ°
CREATE TABLE users (
    id              SERIAL PRIMARY KEY,
    email           VARCHAR(255) UNIQUE NOT NULL,
    email_verified  BOOLEAN DEFAULT false,
    password_hash   VARCHAR(255),
    google_id       VARCHAR(255),
    -- ĞœĞĞ¥ĞĞĞ¢Ğ: encrypted_private_key, encryption_salt, wallet_created_at
    wallet_address  VARCHAR(42),          -- ĞĞŸĞ¦Ğ˜ĞĞĞĞ›ĞĞ: Ğ°ĞºĞ¾ claim-Ğ½Ğµ NFT
    role            VARCHAR(20) DEFAULT 'user',  -- 'user', 'organizer', 'admin'
    failed_login_attempts INT DEFAULT 0,
    locked_until    TIMESTAMP,
    last_login      TIMESTAMP,
    created_at      TIMESTAMP DEFAULT NOW(),
    updated_at      TIMESTAMP DEFAULT NOW()
);

-- ============================================
-- ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞĞ˜ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ˜
-- ============================================

-- EVENTS â€” Ğ½Ğ¾Ğ²Ğ° ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°
CREATE TABLE events (
    id                  SERIAL PRIMARY KEY,
    organizer_user_id   INT REFERENCES users(id),
    
    -- Event info
    event_name          VARCHAR(255) NOT NULL,
    description         TEXT,
    location            VARCHAR(500),
    venue_address       TEXT,
    event_date          DATE,
    event_time          TIME,
    
    -- Blockchain
    contract_address    VARCHAR(42),
    contract_type       VARCHAR(10),       -- 'ERC721' Ğ¸Ğ»Ğ¸ 'ERC1155'
    chain_id            INT,
    deployment_tx       VARCHAR(66),
    
    -- IPFS
    poster_ipfs_cid     VARCHAR(100),      -- ĞĞĞ’: Poster image CID
    metadata_base_cid   VARCHAR(100),      -- ĞĞĞ’: Base metadata folder CID
    
    -- GembaPay
    gembapay_merchant_id VARCHAR(100),     -- ĞĞĞ’: ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² merchant ID
    
    -- Status
    is_active           BOOLEAN DEFAULT true,
    is_canceled         BOOLEAN DEFAULT false,
    is_ended            BOOLEAN DEFAULT false,
    sale_active         BOOLEAN DEFAULT false,
    
    -- Stats
    max_capacity        INT CHECK (max_capacity > 0),
    tickets_sold        INT DEFAULT 0,
    tickets_scanned     INT DEFAULT 0,
    
    -- ĞœĞĞ¥ĞĞĞ¢Ğ: scanner_address, scanner_name, minter_address, encrypted_minter_key
    
    created_at          TIMESTAMP DEFAULT NOW(),
    updated_at          TIMESTAMP DEFAULT NOW()
);

-- TICKET TYPES (ĞĞĞ’ â€” Ğ·Ğ° ERC1155 Ğ·Ğ¾Ğ½Ğ¸)
CREATE TABLE ticket_types (
    id              SERIAL PRIMARY KEY,
    event_id        INT REFERENCES events(id),
    token_type_id   INT NOT NULL,          -- On-chain token type ID
    name            VARCHAR(100) NOT NULL,  -- "General", "VIP", "Backstage"
    price_usd       NUMERIC(10,2),
    price_crypto    VARCHAR(50),           -- "0.01" ETH/BNB
    max_supply      INT NOT NULL,
    minted          INT DEFAULT 0,
    zone_level      INT DEFAULT 0,         -- 0=General, 1=VIP, 2=Backstage, 3=AllAccess
    color_code      VARCHAR(7),            -- "#22C55E" Ğ·Ğ° Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    is_active       BOOLEAN DEFAULT true,
    created_at      TIMESTAMP DEFAULT NOW()
);

-- TICKETS â€” Ğ¿Ñ€ĞµĞ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ½
CREATE TABLE tickets (
    id                  SERIAL PRIMARY KEY,
    event_id            INT REFERENCES events(id),
    ticket_type_id      INT REFERENCES ticket_types(id),
    token_id            INT,                -- On-chain token ID
    serial_number       VARCHAR(100) UNIQUE NOT NULL,
    
    -- Ğ¡Ğ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ¾ÑÑ‚
    owner_user_id       INT REFERENCES users(id),
    original_buyer_id   INT REFERENCES users(id),
    
    -- Security tokens (rotating QR)
    auth_token          VARCHAR(64) NOT NULL,     -- ĞĞĞ’: Ğ·Ğ° live ticket page
    hmac_secret         VARCHAR(64) NOT NULL,     -- ĞĞĞ’: Ğ·Ğ° HMAC QR Ğ¿Ğ¾Ğ´Ğ¿Ğ¸Ñ
    
    -- Device binding
    device_hash         VARCHAR(64),               -- ĞĞĞ’: browser fingerprint
    
    -- Lifecycle
    is_activated        BOOLEAN DEFAULT false,     -- ĞĞĞ’: ÑĞ»ĞµĞ´ Ğ¿ÑŠÑ€Ğ²Ğ¾ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ
    locked_to_user      INT REFERENCES users(id),  -- ĞĞĞ’: Ğ·Ğ°ĞºĞ»ÑÑ‡ĞµĞ½ ĞºÑŠĞ¼ ĞºĞ¾Ğ³Ğ¾
    locked_to_device    VARCHAR(64),               -- ĞĞĞ’: Ğ·Ğ°ĞºĞ»ÑÑ‡ĞµĞ½ ĞºÑŠĞ¼ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾
    activated_at        TIMESTAMP,                 -- ĞĞĞ’
    
    -- NFT Claim
    claim_hash          VARCHAR(66),               -- ĞĞĞ’: hash Ğ·Ğ° claim
    claim_code          VARCHAR(64),               -- ĞĞĞ’: claim ĞºĞ¾Ğ´ (ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¸Ñ€Ğ°Ğ½)
    is_claimed          BOOLEAN DEFAULT false,     -- ĞĞĞ’
    claimed_by          VARCHAR(42),               -- ĞĞĞ’: wallet address
    claimed_at          TIMESTAMP,                 -- ĞĞĞ’
    
    -- Visual state (Ğ·Ğ° "ÑĞ²ĞµÑ‚ĞµÑ‰Ğ¸" NFT)
    visual_status       VARCHAR(20) DEFAULT 'ready',  -- ready/inside/outside/ended
    visual_color        VARCHAR(7) DEFAULT '#FFFFFF',
    visual_zone         VARCHAR(20) DEFAULT 'general',
    
    -- Payment
    payment_provider    VARCHAR(20),               -- 'gembapay_fiat', 'gembapay_crypto'
    payment_id          VARCHAR(255),              -- GembaPay payment ID
    payment_amount      NUMERIC(10,2),
    payment_currency    VARCHAR(10),
    
    -- IPFS
    metadata_ipfs_cid   VARCHAR(100),             -- ĞĞĞ’: per-ticket metadata CID
    
    -- ĞœĞĞ¥ĞĞĞ¢Ğ: qr_code (base64 Ğ² DB), encrypted_private_key, mint_tx
    -- mint_tx ÑĞµ Ğ¿Ğ°Ğ·Ğ¸ Ğ² blockchain events, Ğ½Ğµ Ğ² DB
    
    created_at          TIMESTAMP DEFAULT NOW(),
    updated_at          TIMESTAMP DEFAULT NOW()
);

-- ============================================
-- ĞĞĞ’Ğ˜ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ˜
-- ============================================

-- TRANSFER LOG
CREATE TABLE transfer_log (
    id              SERIAL PRIMARY KEY,
    ticket_id       INT REFERENCES tickets(id),
    from_user_id    INT REFERENCES users(id),
    to_user_id      INT REFERENCES users(id),
    transfer_type   VARCHAR(20),           -- 'platform', 'onchain'
    tx_hash         VARCHAR(66),           -- ĞĞºĞ¾ Ğµ on-chain
    transferred_at  TIMESTAMP DEFAULT NOW()
);

-- SCAN LOGS (Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½)
CREATE TABLE scan_logs (
    id              SERIAL PRIMARY KEY,
    ticket_id       INT REFERENCES tickets(id),
    scanner_id      INT REFERENCES scanners(id),
    scan_type       VARCHAR(10) NOT NULL,  -- 'entry', 'exit'
    scan_result     VARCHAR(20) NOT NULL,  -- 'success', 'denied', 'error'
    deny_reason     VARCHAR(100),          -- ĞĞºĞ¾ denied
    zone            VARCHAR(20),           -- ĞšĞ¾Ñ Ğ·Ğ¾Ğ½Ğ°
    device_hash     VARCHAR(64),           -- Device ĞºĞ¾Ğ¹Ñ‚Ğ¾ Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ» QR
    scan_time       TIMESTAMP DEFAULT NOW()
);

-- SCANNERS (Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½)
CREATE TABLE scanners (
    id                  SERIAL PRIMARY KEY,
    event_id            INT REFERENCES events(id),
    name                VARCHAR(255) NOT NULL,
    location            VARCHAR(255),
    operator_user_id    INT REFERENCES users(id),  -- ĞĞĞ’: Ğ»Ğ¾Ğ³Ğ½Ğ°Ñ‚ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»
    zone_token_type     INT,                        -- ĞĞĞ’: Ğ·Ğ° ĞºĞ¾Ñ Ğ·Ğ¾Ğ½Ğ° ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°
    is_active           BOOLEAN DEFAULT true,
    scanner_secret      VARCHAR(64),                -- ĞĞĞ’: Ğ·Ğ° scanner auth
    created_at          TIMESTAMP DEFAULT NOW(),
    updated_at          TIMESTAMP DEFAULT NOW()
);

-- ORGANIZER PROFILES (ĞĞĞ’)
CREATE TABLE organizer_profiles (
    id                  SERIAL PRIMARY KEY,
    user_id             INT UNIQUE REFERENCES users(id),
    company_name        VARCHAR(255),
    gembapay_merchant_id VARCHAR(100),
    stripe_account_id   VARCHAR(100),
    is_verified         BOOLEAN DEFAULT false,
    reputation_score    INT DEFAULT 100,       -- 0-100, Ğ½Ğ°Ğ¼Ğ°Ğ»ÑĞ²Ğ° Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ¸
    events_created      INT DEFAULT 0,
    events_canceled     INT DEFAULT 0,
    total_tickets_sold  INT DEFAULT 0,
    created_at          TIMESTAMP DEFAULT NOW()
);

-- REFUND TRACKING (ĞĞĞ’)
CREATE TABLE refund_tracking (
    id              SERIAL PRIMARY KEY,
    event_id        INT REFERENCES events(id),
    ticket_id       INT REFERENCES tickets(id),
    payment_id      VARCHAR(255),           -- Original GembaPay payment ID
    refund_amount   NUMERIC(10,2),
    refund_currency VARCHAR(10),
    payment_type    VARCHAR(20),            -- 'fiat' Ğ¸Ğ»Ğ¸ 'crypto'
    refund_status   VARCHAR(20) DEFAULT 'pending',  -- pending/completed/overdue
    refund_deadline TIMESTAMP,              -- ĞšÑ€Ğ°Ğ¹Ğ½Ğ° Ğ´Ğ°Ñ‚Ğ° Ğ·Ğ° refund
    refunded_at     TIMESTAMP,
    created_at      TIMESTAMP DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================

CREATE INDEX idx_tickets_serial ON tickets(serial_number);
CREATE INDEX idx_tickets_owner ON tickets(owner_user_id);
CREATE INDEX idx_tickets_event ON tickets(event_id);
CREATE INDEX idx_tickets_auth_token ON tickets(auth_token);
CREATE INDEX idx_tickets_claim_hash ON tickets(claim_hash);
CREATE INDEX idx_tickets_activated ON tickets(is_activated) WHERE is_activated = true;
CREATE INDEX idx_scan_logs_ticket ON scan_logs(ticket_id);
CREATE INDEX idx_scan_logs_time ON scan_logs(scan_time DESC);
CREATE INDEX idx_transfer_log_ticket ON transfer_log(ticket_id);
CREATE INDEX idx_events_organizer ON events(organizer_user_id);
CREATE INDEX idx_events_active ON events(is_active) WHERE is_active = true;
CREATE INDEX idx_refund_tracking_status ON refund_tracking(refund_status)
    WHERE refund_status = 'pending';
```

---

## 5. FRONTEND (React)

### 5.1 Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```
src/
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ HomePage.jsx               â€” Landing page
â”‚   â”œâ”€â”€ EventsPage.jsx             â€” Browse events
â”‚   â”œâ”€â”€ EventDetailPage.jsx        â€” Single event + buy widget
â”‚   â”œâ”€â”€ LiveTicketPage.jsx         â€” ğŸ†• Live rotating QR (auth required)
â”‚   â”œâ”€â”€ ClaimNFTPage.jsx           â€” ğŸ†• Claim NFT Ñ ĞºĞ¾Ğ´ + MetaMask
â”‚   â”œâ”€â”€ MyTicketsPage.jsx          â€” ĞœĞ¾Ğ¸Ñ‚Ğµ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¸ (list)
â”‚   â”œâ”€â”€ NFTViewerPage.jsx          â€” ğŸ†• 3-page NFT viewer
â”‚   â””â”€â”€ organizer/
â”‚       â”œâ”€â”€ OrganizerDashboard.jsx â€” Manage events
â”‚       â”œâ”€â”€ CreateEventPage.jsx    â€” Create event form
â”‚       â”œâ”€â”€ EventStatsPage.jsx     â€” Real-time scan stats
â”‚       â””â”€â”€ ScannerSetupPage.jsx   â€” Configure scanners
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ tickets/
â”‚   â”‚   â”œâ”€â”€ TicketCard.jsx         â€” Ticket preview card
â”‚   â”‚   â”œâ”€â”€ RotatingQR.jsx         â€” ğŸ†• QR Ñ 30-ÑĞµĞº Ñ€Ğ¾Ñ‚Ğ°Ñ†Ğ¸Ñ
â”‚   â”‚   â”œâ”€â”€ TransferModal.jsx      â€” ğŸ†• ĞŸÑ€ĞµÑ…Ğ²ÑŠÑ€Ğ»Ğ¸ Ğ±Ğ¸Ğ»ĞµÑ‚
â”‚   â”‚   â””â”€â”€ TicketStatusBadge.jsx  â€” Visual status indicator
â”‚   â”œâ”€â”€ nft/
â”‚   â”‚   â”œâ”€â”€ NFTViewer.jsx          â€” ğŸ†• 3-page swipe viewer
â”‚   â”‚   â”œâ”€â”€ AnimatedQR.jsx         â€” ğŸ†• Canvas/WebGL animated QR
â”‚   â”‚   â”œâ”€â”€ GlowEffect.jsx        â€” ğŸ†• Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¸ glow ĞµÑ„ĞµĞºÑ‚Ğ¸
â”‚   â”‚   â””â”€â”€ ClaimButton.jsx        â€” ğŸ†• Claim NFT button + flow
â”‚   â”œâ”€â”€ payment/
â”‚   â”‚   â””â”€â”€ GembaPayWidget.jsx     â€” ğŸ†• GembaPay payment integration
â”‚   â”œâ”€â”€ scanner/
â”‚   â”‚   â”œâ”€â”€ ScannerApp.jsx         â€” ğŸ†• PWA Scanner (camera + verify)
â”‚   â”‚   â”œâ”€â”€ ScanResult.jsx         â€” ğŸ†• Ğ—ĞµĞ»ĞµĞ½/Ñ‡ĞµÑ€Ğ²ĞµĞ½ ĞµĞºÑ€Ğ°Ğ½ + Ğ·Ğ²ÑƒĞº
â”‚   â”‚   â””â”€â”€ LiveFeed.jsx           â€” ğŸ†• Real-time scan dashboard
â”‚   â””â”€â”€ common/
â”‚       â”œâ”€â”€ Header.jsx
â”‚       â”œâ”€â”€ Footer.jsx
â”‚       â””â”€â”€ WalletConnect.jsx      â€” Optional MetaMask connect
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useRotatingQR.js           â€” ğŸ†• 30-sec QR rotation hook
â”‚   â”œâ”€â”€ useWebSocket.js            â€” ğŸ†• Real-time updates
â”‚   â””â”€â”€ useGembaPay.js             â€” ğŸ†• GembaPay SDK hook
â””â”€â”€ services/
    â”œâ”€â”€ api.js                     â€” Backend API client
    â””â”€â”€ web3.js                    â€” Optional Web3 (ÑĞ°Ğ¼Ğ¾ Ğ·Ğ° claim)
```

### 5.2 ĞšĞ»ÑÑ‡Ğ¾Ğ²Ğ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¸

#### NFTViewer.jsx â€” 3-page swipe viewer

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â† Swipe â†’                 â”‚
â”‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â”‚    [PAGE 1: POSTER]   â”‚ â”‚  â† ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ğµ ĞºĞ°Ñ‡Ğ¸Ğ»
â”‚  â”‚    1000x1000          â”‚ â”‚
â”‚  â”‚    Ğ§Ğ¸ÑÑ‚ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½        â”‚ â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                             â”‚
â”‚      â— â—‹ â—‹    1/3          â”‚
â”‚                             â”‚
â”‚  [Claim as NFT]  [Share]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â† Swipe â†’                 â”‚
â”‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Summer Festival 2025 â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚ â”‚
â”‚  â”‚  ğŸ“… 15 August 2025    â”‚ â”‚
â”‚  â”‚  â° 19:00             â”‚ â”‚  â† Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ½Ğ° Ğ¾Ñ‚ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ñ‚Ğ°
â”‚  â”‚  ğŸ“ Sea Garden, Varna â”‚ â”‚
â”‚  â”‚  ğŸ« VIP Access        â”‚ â”‚
â”‚  â”‚  #EVT-2025-0042       â”‚ â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚ â”‚
â”‚  â”‚  ğŸ’ tickets.gemba.bg  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                             â”‚
â”‚      â—‹ â— â—‹    2/3          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â† Swipe â†’                 â”‚
â”‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â”‚   â”‚ â”‚
â”‚  â”‚   â”‚ â–ˆâ–ˆ QR CODE â–ˆâ–ˆ â”‚   â”‚ â”‚  â† Animated, Ğ¿ÑƒĞ»ÑĞ¸Ñ€Ğ°
â”‚  â”‚   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â”‚   â”‚ â”‚     Ğ¦Ğ²ÑÑ‚ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸ Ğ¾Ñ‚ status
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â”‚   Status: â— INSIDE    â”‚ â”‚
â”‚  â”‚   Zone: VIP           â”‚ â”‚
â”‚  â”‚   Scans: 2            â”‚ â”‚
â”‚  â”‚                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                             â”‚
â”‚      â—‹ â—‹ â—    3/3          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ScannerApp.jsx â€” PWA Scanner

```
Standalone PWA (Progressive Web App):
  â†’ Ğ˜Ğ½ÑÑ‚Ğ°Ğ»Ğ¸Ñ€Ğ° ÑĞµ Ğ½Ğ° Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ° Ğ½Ğ° ÑĞºĞµĞ½ĞµÑ€ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ°
  â†’ ĞšĞ°Ğ¼ĞµÑ€Ğ° Ğ´Ğ¾ÑÑ‚ÑŠĞ¿ Ğ·Ğ° QR Ñ‡ĞµÑ‚ĞµĞ½Ğµ
  â†’ Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ¸ fullscreen ĞºĞ°Ñ‚Ğ¾ native app
  â†’ Audio feedback: beep Ğ·Ğ° success, buzz Ğ·Ğ° denied

Flow:
  1. ĞĞ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ğ»Ğ¾Ğ³Ğ²Ğ° ÑĞµ (email + password)
  2. Ğ˜Ğ·Ğ±Ğ¸Ñ€Ğ° event + Ğ·Ğ¾Ğ½Ğ° Ğ·Ğ° ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ°Ğ½Ğµ
  3. ĞšĞ°Ğ¼ĞµÑ€Ğ°Ñ‚Ğ° ÑĞµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ°
  4. Ğ§ĞµÑ‚Ğµ QR â†’ POST /api/v1/scanner/scan
  5. Ğ ĞµĞ·ÑƒĞ»Ñ‚Ğ°Ñ‚:
     âœ… Ğ—ĞµĞ»ĞµĞ½ ĞµĞºÑ€Ğ°Ğ½ + "Ğ’Ğ›Ğ•Ğ—" + beep sound
     âŒ Ğ§ĞµÑ€Ğ²ĞµĞ½ ĞµĞºÑ€Ğ°Ğ½ + Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° + buzz sound
  6. Auto-reset Ğ·Ğ° ÑĞ»ĞµĞ´Ğ²Ğ°Ñ‰ scan (2 ÑĞµĞº)

Offline mode:
  â†’ Cache Ğ½Ğ° ticket serial numbers Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°Ğ½Ğµ
  â†’ ĞŸÑ€Ğ¸ Ğ»Ğ¸Ğ¿ÑĞ° Ğ½Ğ° internet: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ€ĞµÑ‰Ñƒ cache
  â†’ ĞŸÑ€Ğ¸ Ğ²ÑŠĞ·ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ÑĞ²Ğ°Ğ½Ğµ: sync pending scans
```

---

## 6. INFRASTRUCTURE

### 6.1 Hetzner VPS Setup

```
VPS 1 (Primary â€” Falkenstein):
  â”œâ”€â”€ Node.js Backend (PM2)
  â”œâ”€â”€ PostgreSQL 16
  â”œâ”€â”€ Redis 7
  â”œâ”€â”€ IPFS Node (Kubo)
  â”œâ”€â”€ Nginx (reverse proxy)
  â””â”€â”€ Certbot (SSL)

VPS 2 (Fallback â€” Helsinki):
  â”œâ”€â”€ Node.js Backend (PM2) â€” hot standby
  â”œâ”€â”€ PostgreSQL 16 â€” streaming replication
  â”œâ”€â”€ Redis 7 â€” replica
  â”œâ”€â”€ IPFS Node (Kubo) â€” pin mirror
  â””â”€â”€ Nginx

Cloudflare:
  â”œâ”€â”€ DNS
  â”œâ”€â”€ Load Balancer (failover)
  â”œâ”€â”€ DDoS protection
  â””â”€â”€ SSL termination

Ğ”Ğ¾Ğ¼ĞµĞ¹Ğ½Ğ¸:
  tickets.gembapay.com    â€” Frontend
  api.tickets.gembapay.com â€” Backend API
  ipfs.gembapay.com       â€” IPFS Gateway
  scanner.gembapay.com    â€” Scanner PWA
```

### 6.2 IPFS Setup

```bash
# ĞĞ° Ğ²ÑĞµĞºĞ¸ VPS:
ipfs init
ipfs config Addresses.API /ip4/127.0.0.1/tcp/5001
ipfs config Addresses.Gateway /ip4/0.0.0.0/tcp/8080

# Peer Ğ´Ğ²Ğ°Ñ‚Ğ° node-Ğ°:
ipfs swarm connect /ip4/<VPS2_IP>/tcp/4001/p2p/<VPS2_PEER_ID>

# Auto-pin Ğ¼ĞµĞ¶Ğ´Ñƒ node-Ğ¸Ñ‚Ğµ:
# Ğ’ÑĞµĞºĞ¸ upload â†’ pin Ğ½Ğ° primary â†’ replicate Ğ½Ğ° secondary
```

---

## 7. GEMBAPAY Ğ˜ĞĞ¢Ğ•Ğ“Ğ ĞĞ¦Ğ˜Ğ¯

### 7.1 ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ Onboarding

```
1. ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ ÑĞµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ° Ğ² ticket Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°
2. ĞĞ°Ñ‚Ğ¸ÑĞºĞ° "Ğ¡Ñ‚Ğ°Ğ½Ğ¸ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€"
3. ĞŸÑ€ĞµĞ½Ğ°ÑĞ¾Ñ‡Ğ²Ğ°Ğ½Ğµ ĞºÑŠĞ¼ GembaPay merchant onboarding:
   â†’ Stripe Connect onboarding (Ğ·Ğ° ĞºĞ°Ñ€Ñ‚Ğ¸)
   â†’ Ğ˜Ğ·Ğ±Ğ¾Ñ€ Ğ½Ğ° crypto Ğ¼Ñ€ĞµĞ¶Ğ¸ Ğ¸ Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ¸
   â†’ KYC (Ğ°ĞºĞ¾ Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ° Stripe)
4. Webhook: merchant.onboarded â†’ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ²Ğ° merchant_id
5. ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ğ¼Ğ¾Ğ¶Ğµ Ğ´Ğ° ÑÑŠĞ·Ğ´Ğ°Ğ²Ğ° ÑÑŠĞ±Ğ¸Ñ‚Ğ¸Ñ
```

### 7.2 Payment Flow

```
TICKET PURCHASE:
  1. Buyer â†’ EventDetailPage â†’ Ğ¸Ğ·Ğ±Ğ¸Ñ€Ğ° Ğ±Ğ¸Ğ»ĞµÑ‚ â†’ [Buy]
  2. GembaPay Widget Ğ¾Ñ‚Ğ²Ğ°Ñ€Ñ ÑĞµ:
     â†’ ĞšĞ°Ñ€Ñ‚Ğ° (Visa/MC) â†’ Stripe Connect â†’ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ½Ğ° Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°
     â†’ Crypto (ETH/BNB/MATIC/USDT) â†’ GembaPay Protocol â†’ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ½Ğ° Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°
  3. GembaPay Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ split: 95% â†’ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€, 5% â†’ GEMBA EOOD
  4. Webhook â†’ backend â†’ mint NFT â†’ email Ğ±Ğ¸Ğ»ĞµÑ‚

EVENT CREATION:
  1. ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ â†’ CreateEventPage â†’ Ğ¿Ğ¾Ğ¿ÑŠĞ»Ğ²Ğ° Ñ„Ğ¾Ñ€Ğ¼Ğ°
  2. GembaPay Widget: Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼ĞµĞ½Ğ° Ñ‚Ğ°ĞºÑĞ° ($5-10)
  3. Webhook â†’ backend â†’ deploy EventContract â†’ IPFS upload
  4. ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ÑŠÑ‚ Ğ²Ğ¸Ğ¶Ğ´Ğ°: "Ğ¡ÑŠĞ±Ğ¸Ñ‚Ğ¸ĞµÑ‚Ğ¾ Ğµ ÑÑŠĞ·Ğ´Ğ°Ğ´ĞµĞ½Ğ¾!"
```

---

## 8. Ğ¤ĞĞ—Ğ˜ ĞĞ Ğ ĞĞ—Ğ ĞĞ‘ĞĞ¢ĞšĞ

### Ğ¤ĞĞ—Ğ 1: Smart Contracts (2-3 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸)

```
Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 1:
  â–¡ EventContract721 v2 (buyTicketCrypto, mintWithFiatProof)
  â–¡ EventContract1155 v2 (ticket types, Ğ·Ğ¾Ğ½Ğ¸)
  â–¡ ClaimContract (lock, claim, renounce)
  â–¡ Unit tests Ğ·Ğ° Ğ²ÑĞµĞºĞ¸ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 2:
  â–¡ FactoryFacet v2 (Diamond proxy, event deployment)
  â–¡ TreasuryFacet (fee collection)
  â–¡ Integration tests (full flow)
  â–¡ Slither + Mythril security audit

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 3:
  â–¡ Testnet deploy (Polygon Amoy)
  â–¡ Gas optimization
  â–¡ Edge case testing
  â–¡ Fix audit findings
```

### Ğ¤ĞĞ—Ğ 2: Backend (2-3 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸)

```
Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 4:
  â–¡ ĞĞ¾Ğ²Ğ° DB schema + migration Ğ¾Ñ‚ v1
  â–¡ scannerService.js (rotating QR, HMAC, device binding)
  â–¡ transferService.js (ticket transfers)
  â–¡ claimService.js (claim code generation)

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 5:
  â–¡ metadataService.js (3-page metadata, IPFS upload)
  â–¡ GembaPay webhook handler
  â–¡ Event creation flow (deploy + IPFS)
  â–¡ Blockchain service v2 (contract interactions)

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 6:
  â–¡ API endpoints (Ğ²ÑĞ¸Ñ‡ĞºĞ¸ routes)
  â–¡ WebSocket Ğ·Ğ° real-time scan feed
  â–¡ Email templates (claim ĞºĞ¾Ğ´, ticket, transfer)
  â–¡ Integration testing
```

### Ğ¤ĞĞ—Ğ 3: Frontend (2-3 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸)

```
Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 7:
  â–¡ Event pages (browse, detail, buy)
  â–¡ GembaPay widget Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ
  â–¡ Live Ticket Page (rotating QR)
  â–¡ My Tickets page

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 8:
  â–¡ NFT Viewer (3-page swipe, animated QR, glow effects)
  â–¡ Claim NFT page (MetaMask connect + claim flow)
  â–¡ Transfer modal
  â–¡ Organizer dashboard (create event, stats)

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 9:
  â–¡ Scanner PWA (ĞºĞ°Ğ¼ĞµÑ€Ğ°, QR Ñ‡ĞµÑ‚ĞµĞ½Ğµ, Ğ·Ğ²ÑƒÑ†Ğ¸)
  â–¡ Live scan feed dashboard
  â–¡ Mobile responsive polish
  â–¡ Apple/Google Wallet integration (stretch goal)
```

### Ğ¤ĞĞ—Ğ 4: Infrastructure + Launch (1-2 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸)

```
Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 10:
  â–¡ IPFS node setup (primary + fallback)
  â–¡ Production deploy Ğ½Ğ° Polygon mainnet
  â–¡ Cloudflare LB configuration
  â–¡ SSL, DNS, security headers

Ğ¡ĞµĞ´Ğ¼Ğ¸Ñ†Ğ° 11:
  â–¡ End-to-end testing (full flow)
  â–¡ Load testing (concurrent scans)
  â–¡ Security review
  â–¡ Soft launch Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾ ÑÑŠĞ±Ğ¸Ñ‚Ğ¸Ğµ
```

---

## 9. SECURITY CHECKLIST

```
Smart Contracts:
  â–¡ ReentrancyGuard Ğ½Ğ° Ğ²ÑĞ¸Ñ‡ĞºĞ¸ payable Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
  â–¡ Check-Effects-Interactions pattern
  â–¡ Access control: onlyOwner, onlyPlatform
  â–¡ Integer overflow protection (Solidity 0.8+)
  â–¡ Slither audit â€” 0 high/critical
  â–¡ Mythril symbolic execution
  â–¡ Manual review Ğ½Ğ° payment splitting

Backend:
  â–¡ JWT Ñ expiration + refresh tokens
  â–¡ Rate limiting Ğ½Ğ° Ğ²ÑĞ¸Ñ‡ĞºĞ¸ endpoints
  â–¡ HMAC verification Ğ·Ğ° QR
  â–¡ Input validation (express-validator)
  â–¡ SQL injection prevention (parameterized queries)
  â–¡ XSS prevention (CSP headers)
  â–¡ CORS configuration
  â–¡ Webhook signature verification (GembaPay)
  â–¡ Device fingerprinting Ğ·Ğ° ticket binding

Frontend:
  â–¡ No sensitive data Ğ² localStorage
  â–¡ CSP meta tags
  â–¡ XSS sanitization
  â–¡ Secure WebSocket connections
  â–¡ Camera permissions handling (Scanner PWA)

Infrastructure:
  â–¡ PostgreSQL encrypted connections
  â–¡ Redis password authentication
  â–¡ IPFS API Ğ½Ğµ Ğµ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑŠĞ¿ĞµĞ½
  â–¡ Firewall rules (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 80, 443)
  â–¡ Automatic security updates
  â–¡ Backup strategy (daily DB + IPFS pins)
```

---

## 10. ĞĞ‘ĞĞ‘Ğ©Ğ•ĞĞ˜Ğ•

### ĞšĞ°ĞºĞ²Ğ¾ Ğ¿Ğ¾ÑÑ‚Ğ¸Ğ³Ğ°Ğ¼Ğµ

| Ğ¥Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€Ğ¸ÑÑ‚Ğ¸ĞºĞ° | v1 (ÑĞµĞ³Ğ°) | v2 (Ğ¿Ğ»Ğ°Ğ½) |
|----------------|-----------|-----------|
| Custody | âŒ Custodial (PK + fiat) | âœ… Zero custody |
| Blockchain Ğ·Ğ½Ğ°Ğ½Ğ¸Ñ | âŒ ĞÑƒĞ¶Ğ½Ğ¸ | âœ… ĞĞµ ÑĞ° Ğ½ÑƒĞ¶Ğ½Ğ¸ |
| ĞŸĞ»Ğ°Ñ‰Ğ°Ğ½Ğ¸Ñ | âŒ Ğ”Ğ¸Ñ€ĞµĞºÑ‚ĞµĞ½ Stripe | âœ… GembaPay (non-custodial) |
| NFT Metadata | âŒ ĞÑĞ¼Ğ° | âœ… IPFS + dynamic |
| Scanner | âŒ ĞÑĞ¼Ğ° app | âœ… PWA + rotating QR |
| Anti-fraud | âŒ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ĞµĞ½ | âœ… HMAC + device bind + lock |
| Solidity LOC | ~4150 | ~1280 |
| Backend LOC | ~12700 | ~8000 (est.) |
| Ğ ĞµĞ³ÑƒĞ»Ğ°Ñ†Ğ¸Ñ | âŒ CASP Ğ½ÑƒĞ¶ĞµĞ½ | âœ… Ğ§Ğ¸ÑÑ‚ |
| Refunds | âŒ ĞÑĞ¼Ğ° | âœ… Tracking + reputation |
| NFT Experience | âŒ ĞŸÑ€Ğ°Ğ·Ğ½Ğ¸ NFT-Ñ‚Ğ° | âœ… 3-page animated |

### Ğ’Ñ€ĞµĞ¼ĞµĞ²Ğ° Ñ€Ğ°Ğ¼ĞºĞ°

- **ĞĞ±Ñ‰Ğ¾:** 10-11 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸
- **MVP (contracts + backend + basic frontend):** 6-7 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸
- **Full launch:** 10-11 ÑĞµĞ´Ğ¼Ğ¸Ñ†Ğ¸

### Ğ Ğ¸ÑĞºĞ¾Ğ²Ğµ

| Ğ Ğ¸ÑĞº | Ğ’ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ | ĞœĞ¸Ñ‚Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ |
|------|-----------|-----------|
| GembaPay API Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ğ¸ | ĞĞ¸ÑĞºĞ° | ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¾Ğ½ĞµĞ½ ÑĞ»Ğ¾Ğ¹, Ğ»ĞµÑĞ½Ğ° Ğ¿Ğ¾Ğ´Ğ¼ÑĞ½Ğ° |
| IPFS node downtime | Ğ¡Ñ€ĞµĞ´Ğ½Ğ° | Dual-node + Cloudflare cache |
| Gas spike Ğ½Ğ° Polygon | ĞĞ¸ÑĞºĞ° | Batch minting, L2 fallback |
| Scanner offline | Ğ¡Ñ€ĞµĞ´Ğ½Ğ° | Offline cache + sync |
| ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ Ğ½Ğµ Ğ²Ñ€ÑŠÑ‰Ğ° refund | Ğ¡Ñ€ĞµĞ´Ğ½Ğ° | Reputation ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° + Ğ±Ğ°Ğ½ |
